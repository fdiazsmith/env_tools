#!/usr/bin/env python3

"""
vidcli - Video CLI tool for video processing with ffmpeg
"""

import argparse
import os
import subprocess
import sys
from pathlib import Path


# Color codes for terminal output
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color


def print_error(message):
    """Print error message in red"""
    print(f"{Colors.RED}Error: {message}{Colors.NC}", file=sys.stderr)


def print_success(message):
    """Print success message in green"""
    print(f"{Colors.GREEN}✓ {message}{Colors.NC}")


def print_info(message):
    """Print info message in blue"""
    print(f"{Colors.BLUE}{message}{Colors.NC}")


def print_warning(message):
    """Print warning message in yellow"""
    print(f"{Colors.YELLOW}⚠ {message}{Colors.NC}")


def check_ffmpeg():
    """Check if ffmpeg is installed"""
    try:
        subprocess.run(['ffmpeg', '-version'],
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL,
                      check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def get_image_sequence_info(folder_path):
    """Get info about image sequence in folder"""
    folder = Path(folder_path)
    if not folder.is_dir():
        return None, None, None

    # supported image extensions
    img_exts = {'.png', '.jpg', '.jpeg', '.tiff', '.tif', '.bmp', '.webp'}

    # find all images
    images = sorted([f for f in folder.iterdir()
                     if f.suffix.lower() in img_exts])

    if not images:
        return None, None, None

    # detect pattern - find common prefix and extension
    ext = images[0].suffix
    # check all have same extension
    if not all(f.suffix == ext for f in images):
        print_warning("Mixed image formats found, using first format")
        images = [f for f in images if f.suffix == ext]

    return images, ext, len(images)


def get_image_dimensions(image_path):
    """Get image dimensions using ffprobe"""
    try:
        result = subprocess.run([
            'ffprobe', '-v', 'error',
            '-select_streams', 'v:0',
            '-show_entries', 'stream=width,height',
            '-of', 'csv=p=0',
            str(image_path)
        ], capture_output=True, text=True, check=True)
        width, height = result.stdout.strip().split(',')
        return int(width), int(height)
    except Exception:
        return None, None


def sequence_to_video(folder_path, output_file=None, fps=30, resolution=None, scale=None, bg_color='black'):
    """
    Convert image sequence to video

    Args:
        folder_path: Path to folder containing image sequence
        output_file: Output video path (optional)
        fps: Frames per second (default 30)
        resolution: Tuple of (width, height) or None
        scale: Float multiplier for scaling
        bg_color: Background color for transparency (default 'black')
    """
    folder = Path(folder_path).resolve()

    if not folder.is_dir():
        print_error(f"Folder not found: {folder_path}")
        return False

    images, ext, count = get_image_sequence_info(folder)

    if not images:
        print_error(f"No images found in: {folder_path}")
        return False

    print_info(f"Found {count} images ({ext})")

    # get dimensions from first image
    img_w, img_h = get_image_dimensions(images[0])
    if not img_w:
        print_error("Could not determine image dimensions")
        return False

    print_info(f"Image size: {img_w}x{img_h}")

    # generate output filename
    if output_file is None:
        output_file = str(folder.parent / f"{folder.name}_seq.mp4")

    # check overwrite
    if os.path.exists(output_file):
        response = input(f"{Colors.YELLOW}Output '{output_file}' exists. Overwrite? (y/n): {Colors.NC}")
        if response.lower() not in ['y', 'yes']:
            print("Cancelled.")
            return False

    # build ffmpeg command using glob pattern
    pattern = str(folder / f"*{ext}")

    # build filter - composite on solid color to handle alpha
    # then optionally scale
    scale_filter = ''
    if resolution:
        width, height = resolution
        scale_filter = f',scale={width}:{height}'
        print_info(f"Resizing to {width}x{height}")
    elif scale:
        scale_filter = f',scale=trunc(iw*{scale}/2)*2:trunc(ih*{scale}/2)*2'
        print_info(f"Scaling by {scale}x")

    # alpha compositing: create solid bg, overlay images on it
    filter_str = f'color=c={bg_color}:s={img_w}x{img_h}:r={fps}[bg];[bg][0:v]overlay=shortest=1{scale_filter}'
    print_info(f"Background: {bg_color}")

    cmd = [
        'ffmpeg',
        '-framerate', str(fps),
        '-pattern_type', 'glob',
        '-i', pattern,
        '-filter_complex', filter_str,
        '-c:v', 'libx264',
        '-preset', 'medium',
        '-crf', '23',
        '-pix_fmt', 'yuv420p',
        '-movflags', '+faststart',
        '-y', output_file,
    ]

    print_info(f"Input: {folder}")
    print_info(f"FPS: {fps}")
    print_info(f"Output: {output_file}")
    print()

    try:
        subprocess.run(cmd, check=True)
        print()
        print_success(f"Created: {output_file}")

        output_size = os.path.getsize(output_file) / (1024 * 1024)
        print_info(f"Output size: {output_size:.2f} MB")
        return True

    except subprocess.CalledProcessError as e:
        print_error(f"ffmpeg failed: {e}")
        return False
    except KeyboardInterrupt:
        print()
        print_warning("Cancelled")
        if os.path.exists(output_file):
            os.remove(output_file)
        return False


def get_video_info(input_file):
    """Get video information using ffprobe"""
    try:
        result = subprocess.run([
            'ffprobe', '-v', 'error',
            '-select_streams', 'v:0',
            '-show_entries', 'stream=width,height',
            '-of', 'csv=p=0',
            input_file
        ], capture_output=True, text=True, check=True)

        width, height = result.stdout.strip().split(',')
        return int(width), int(height)
    except Exception as e:
        print_warning(f"Could not get video info: {e}")
        return None, None


def parse_resolution(res_string):
    """Parse resolution string (e.g., '1920x1080') into width and height"""
    try:
        parts = res_string.lower().split('x')
        if len(parts) != 2:
            raise ValueError("Resolution must be in format WIDTHxHEIGHT")

        width = int(parts[0])
        height = int(parts[1])

        if width <= 0 or height <= 0:
            raise ValueError("Width and height must be positive numbers")

        return width, height
    except ValueError as e:
        print_error(f"Invalid resolution format: {e}")
        return None, None


def optimize_for_web(input_file, output_file=None, resolution=None, scale=None):
    """
    Convert video to web-optimized MP4 format

    Args:
        input_file: Path to input video file
        output_file: Path to output file (optional)
        resolution: Tuple of (width, height) or None to maintain original
        scale: Float multiplier to scale video dimensions (e.g., 0.5 for half size)
    """
    # Validate input file
    if not os.path.isfile(input_file):
        print_error(f"Input file not found: {input_file}")
        return False

    # Generate output filename if not provided
    if output_file is None:
        input_path = Path(input_file)
        output_file = str(input_path.parent / f"{input_path.stem}_web.mp4")

    # Check if output file already exists
    if os.path.exists(output_file):
        response = input(f"{Colors.YELLOW}Output file '{output_file}' already exists. Overwrite? (y/n): {Colors.NC}")
        if response.lower() not in ['y', 'yes']:
            print("Operation cancelled.")
            return False

    # Build ffmpeg command
    cmd = [
        'ffmpeg',
        '-i', input_file,
        '-c:v', 'libx264',          # H.264 video codec
        '-preset', 'medium',         # Encoding speed/compression tradeoff
        '-crf', '23',                # Quality (lower = better, 23 is default)
        '-c:a', 'aac',               # AAC audio codec
        '-b:a', '128k',              # Audio bitrate
        '-movflags', '+faststart',   # Enable fast start for web playback
    ]

    # Add resolution scaling if specified
    if resolution:
        width, height = resolution
        cmd.extend(['-vf', f'scale={width}:{height}'])
        print_info(f"Resizing to {width}x{height}")
    elif scale:
        # Round to even numbers (required for H.264)
        cmd.extend(['-vf', f'scale=trunc(iw*{scale}/2)*2:trunc(ih*{scale}/2)*2'])
        print_info(f"Scaling by {scale}x")

    # Add output file
    cmd.extend(['-y', output_file])  # -y to overwrite without asking

    # Show the command being executed
    print_info(f"Converting: {os.path.basename(input_file)}")
    if resolution:
        print_info(f"Resolution: {resolution[0]}x{resolution[1]}")
    else:
        orig_width, orig_height = get_video_info(input_file)
        if orig_width and orig_height:
            print_info(f"Resolution: {orig_width}x{orig_height} (original)")

    print_info(f"Output: {output_file}")
    print()

    try:
        # Run ffmpeg
        subprocess.run(cmd, check=True)
        print()
        print_success(f"Successfully created: {output_file}")

        # Show file sizes
        input_size = os.path.getsize(input_file) / (1024 * 1024)
        output_size = os.path.getsize(output_file) / (1024 * 1024)
        print_info(f"Input size:  {input_size:.2f} MB")
        print_info(f"Output size: {output_size:.2f} MB")

        if output_size < input_size:
            savings = ((input_size - output_size) / input_size) * 100
            print_success(f"Size reduced by {savings:.1f}%")

        return True

    except subprocess.CalledProcessError as e:
        print_error(f"ffmpeg conversion failed: {e}")
        return False
    except KeyboardInterrupt:
        print()
        print_warning("Operation cancelled by user")
        # Clean up partial output file
        if os.path.exists(output_file):
            os.remove(output_file)
            print_info("Cleaned up partial output file")
        return False


def show_interactive_menu():
    """Display interactive menu for video operations"""
    while True:
        print()
        print(f"{Colors.GREEN}{'=' * 50}{Colors.NC}")
        print(f"{Colors.GREEN}         vidcli - Video Processing Tool{Colors.NC}")
        print(f"{Colors.GREEN}{'=' * 50}{Colors.NC}")
        print()
        print("Available operations:")
        print()
        print(f"  {Colors.BLUE}1.{Colors.NC} Optimize video for web (MP4)")
        print(f"  {Colors.BLUE}2.{Colors.NC} Exit")
        print()

        try:
            choice = input(f"Select an option (1-2): ").strip()

            if choice == '1':
                print()
                input_file = input("Enter path to video file: ").strip()

                if not input_file:
                    print_error("No input file provided")
                    continue

                # Ask about resolution
                resize = input("Resize video? (y/n): ").strip().lower()
                resolution = None

                if resize in ['y', 'yes']:
                    res_input = input("Enter resolution (e.g., 1920x1080): ").strip()
                    resolution = parse_resolution(res_input)
                    if not resolution:
                        continue

                # Ask about output file
                output_file = input("Output file (press Enter for auto-naming): ").strip()
                if not output_file:
                    output_file = None

                print()
                optimize_for_web(input_file, output_file, resolution)

            elif choice == '2':
                print("Goodbye!")
                sys.exit(0)
            else:
                print_error("Invalid option")

        except KeyboardInterrupt:
            print()
            print("Goodbye!")
            sys.exit(0)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Video processing CLI tool using ffmpeg',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive mode
  vidcli

  # Convert to web-optimized MP4 (same resolution)
  vidcli --web video.mov

  # Convert and resize to 1920x1080
  vidcli --web video.mov --res 1920x1080

  # Scale video by 0.5 (half size)
  vidcli --web video.mov --scale 0.5

  # Image sequence to video (folder with images)
  vidcli --seq ./frames/

  # Image sequence with custom fps
  vidcli --seq ./frames/ --fps 60

  # Image sequence with white background (for transparent PNGs)
  vidcli --seq ./frames/ --bg white

  # Image sequence with scaling
  vidcli --seq ./frames/ --fps 24 --scale 0.5

Output:
  --web: files named '{input}_web.mp4'
  --seq: files named '{folder}_seq.mp4'
  Use --output to specify custom path.
        """
    )

    parser.add_argument('--web', metavar='INPUT',
                       help='Optimize video for web (converts to MP4)')

    parser.add_argument('--seq', metavar='FOLDER',
                       help='Convert image sequence folder to video')

    parser.add_argument('--fps', type=int, default=30, metavar='FPS',
                       help='Frame rate for image sequence (default: 30)')

    parser.add_argument('--bg', default='black', metavar='COLOR',
                       help='Background color for transparent images (default: black)')

    parser.add_argument('--res', '--resolution', metavar='WIDTHxHEIGHT',
                       help='Resize video to specified resolution (e.g., 1920x1080)')

    parser.add_argument('--scale', type=float, metavar='MULTIPLIER',
                       help='Scale video by multiplier (e.g., 0.5 for half size, 2.0 for double)')

    parser.add_argument('--output', '-o', metavar='FILE',
                       help='Output file path')

    # Parse arguments
    args = parser.parse_args()

    # Check if ffmpeg is installed
    if not check_ffmpeg():
        print_error("ffmpeg is not installed or not in PATH")
        print_info("Install ffmpeg:")
        print_info("  macOS:  brew install ffmpeg")
        print_info("  Ubuntu: sudo apt install ffmpeg")
        sys.exit(1)

    # If no arguments provided, show interactive menu
    if len(sys.argv) == 1:
        show_interactive_menu()
        return

    # Handle --web command
    if args.web:
        resolution = None
        scale = None

        # Parse resolution if provided
        if args.res:
            resolution = parse_resolution(args.res)
            if not resolution:
                sys.exit(1)

        # Check for scale
        if args.scale:
            if args.scale <= 0:
                print_error("Scale multiplier must be positive")
                sys.exit(1)
            scale = args.scale

        # Check if both resolution and scale are specified
        if args.res and args.scale:
            print_error("Cannot use --res and --scale together. Choose one.")
            sys.exit(1)

        # Run optimization
        success = optimize_for_web(args.web, args.output, resolution, scale)
        sys.exit(0 if success else 1)

    # Handle --seq command
    if args.seq:
        resolution = None
        scale = None

        if args.res:
            resolution = parse_resolution(args.res)
            if not resolution:
                sys.exit(1)

        if args.scale:
            if args.scale <= 0:
                print_error("Scale multiplier must be positive")
                sys.exit(1)
            scale = args.scale

        if args.res and args.scale:
            print_error("Cannot use --res and --scale together. Choose one.")
            sys.exit(1)

        success = sequence_to_video(args.seq, args.output, args.fps, resolution, scale, args.bg)
        sys.exit(0 if success else 1)

    # If options provided without --web or --seq, show error
    if args.res or args.scale or args.output or args.fps != 30:
        print_error("--res, --scale, --output, --fps require --web or --seq")
        sys.exit(1)

    # Should not reach here, but just in case
    parser.print_help()


if __name__ == '__main__':
    main()
